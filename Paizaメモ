Paizaメモ

getsメソッド
　ユーザーがキーボードで入力した値を文字列として取得するメソッド

chompメゾット
　getsメゾットと合わせて使うことが多い。getsメゾットは改行文字（\n）を含むため、chompメゾットにて改行文字を取り除く。

readlinesメゾット
　readlinesメゾットは、すべての行を読み取り、１行ごとの配列に格納します。readlinesメゾットは、改行文字（\n）を含む。
　["10\n", "12\n", "4\n", "8\n", "46\n"]　←こんな感じでね。
　なので、　readlines.map(&:chomp) とすると配列の中身は文字列となり、改行文字が消えてOK
           →数値として受け取りたいなら、readlines.map{ |n| n.chomp.to_i}とchompとto_iを行える。
　
to_iメソッド
　数字の文字列を数値オブジェクトに変換するメソッドです。
　to_iメソッドは文字列から改行文字を無視して数値に変換する事が出来る。
　なので、input = readlines.map(&:to_i)　とすると、改行文字も消えて数値の配列となる。

timesメゾット
　Integerクラスのメソッドです。指定した整数オブジェクトの回数だけdo~end内に記述する処理が繰り返し実行されます。

powメゾット
　Integer クラスで用意されている累乗できるメゾット　数値.pow(2) とすると2乗数値に対いて2乗する

splitメソッド
　文字列を指定した区切り文字で分割し、配列で返すメソッド。
  →デフォルトで空白（スペース、タブ、改行など）を区切り文字として扱う。デフォルト以外は引数で指定する。
　→改行文字を無視することが出来る。　"1 2 3\n" という文字列を splitで分割すると、改行は無視されて "1", "2", "3" という配列ができる

mapメゾット
　Arrayクラスで用意されるメゾット　配列の各要素に対して処理を行った結果を配列で返してくれるメソッドです。
  配列.map { |変数| 実行する処理 }
　また、mapメゾットではwith_indexと付けることで各要素のインデックスを取得することが出来る。
  配列.map.with_index { |n,index| 処理内容～}　といった感じ。 

minメゾット
　Arrayクラスで用意されているメゾット。配列内の最小値を求める。
　puts 配列.min とすると配列内の最小値が出力
maxメゾットは逆ね。

pushメゾット
　Arrayクラスで用意されているメゾット。指定した値を配列の末端に追加する。
　array.push 4
　array.push [5, 6]　こんな感じで配列に追加できる。

popメゾット
　Arrayクラスで用意されているメゾット。配列の末端の値を削除する。
　array = [1, [2, 3], 4]
　p array.pop      # => 4　が削除される

joinメゾット
  Arrayクラスで用意されているメソッド。
  配列の各要素を1つの文字列に結合する。join("-") joinメゾットの引数には何で結合するか　を与える。

slice!メゾット
　Arrayクラスで用意されているメソッド。
　配列から指定した要素を取り出すことができるメソッド。
　slice ! の！がついている場合は、要素を取り出すだけでなく削除する。 配列.sline!(インデックス番号指定)と書く。

sortメゾット
　Arrayクラスで用意されているメソッド。
　配列内の順番を入れ替え、配列を返す。

indluce?メゾット
Arrayクラスで用意されているメソッド。
配列内に指定した値があるかtrue　or falseで返すメゾット
a = [ "a", "b", "c" ]
a.include?("b")       #=> true
a.include?("z")       #=> false

uniqメゾット
Arrayクラスで用意されているメソッド。
配列から重複した要素を取り除いた新しい配列を返します。

reverseメゾット
　Arrayクラス　Stringクラスで用意されているメゾット。
　配列の中身、文字列の中身を入れ替える(前後に)

lengthメゾット
　Arrayクラス　Stringクラスどちらでも用意されているメゾット。
　配列の要素数、文字数をカウントします。！

charsメゾット
　Stringクラスで用意されているメゾット。
　文字列の各文字を文字列の配列で返します。
　"hello世界".chars # => ["h", "e", "l", "l", "o", "世", "界"]

countメゾット
　Stringクラスで用意されているメゾット。
  引数で指定された文字が文字列にいくつあるか数えます。
　　p 'abcdefg'.count('c')               # => 1

to_aメゾット
　ハッシュや範囲オブジェクトを配列にすることができるメゾット

浮動小数点数のクラス　Floatクラスという。
　to_fメゾットを使うと、selfを返します。　3.14.to_f   # => 3.14
　 gets.to_iだと　3.14を3と整数(Integer)となるが、　gets.to_fだと、3.14を3.14(Float)となる
　→ちなみにto_fメゾットはStingクラス Integerクラスにて用意されているメゾット

　roundメゾットは、引数で指定した数値の小数桁数を四捨五入する。　t = 3.141592653 で　t.round(3)   # => 3.142

keysメゾット
　Hashクラスにあるメゾット。
　Hashにあるキーを配列で取得することができる。
　h1 = { "a" => 100, 2 => ["some"], :c => "c" }
　p h1.keys           #=> ["a", 2, :c]

 key?メゾット
  Hashクラスにあるメゾット。
  ハッシュが特定のキーとして持つ時true 無いときfalseと返します。
　p({1 => "one"}.key?(1)) # => true
　p({1 => "one"}.key?(2)) # => false

valuesメゾット
　Hashクラスにあるメゾット。
　ハッシュの全値の配列を返します。

if文について
　if 三項演算子について　条件式 ? 「真(true)」となった場合に実行したい処理 : 「偽(false)」となった場合に実行したい処理
　if 修飾子　いわゆる後置if

％記法･･･文字列リテラルの一つ
　%wを使うと、文字列を配列にできる。　%w( 1 2 3) とすると[1,2,3]といった感じ

sprintfフォーマット･･･これはフォーマット指定子を使って値を整形するためのメソッドで、数値や文字列を特定の形式で出力するために使う。
　sprintf("%.3f", 10) #=> "10.000" 第一引数にフォーマットを指定し(今回は、小数点3桁まで)、第二引数では10と指定することで、10.000 と出力される。

　sprintf( "%3d", 1000 ) →　これは数値を3桁ごとに半角スペースを入れる書き方。
　dは、整数（decimal）の事であり、i 整数(Integer)にすると8進数として使用されるためdを使用する。

  sprintf( "%03d", N ) →これは、数値を 3 けたになるよう数値の前に 0 を埋めて出力するやりかた。
　詳細は　リファレンスマニュアルを確認(https://docs.ruby-lang.org/ja/latest/doc/print_format.html)

puts print p メゾットの違い
 putsメゾット　出力後改行する。
 printメゾット　出力後改行しない。 引数として与えられたオブジェクトを改行を含まない「形式」で出力します。←形式なので配列をprintすると、[3,1,2]と出力される。
 pメゾット　出力後改行する。　オブジェクトを見やすいように出力する　""や [] も含めて出力する。

計算
　#{A / B} A÷Bと同じ 
　#{A % B} A÷Bの余り値
代入演算子
　「+=」「-=」「*=」「/=」「%=」
　こんな感じ。　 a += 3 →　a = a+3 と同じ。＝の左側に入れる。
自己代入演算子
　||=　
　これは、左辺が 偽 か 未定義 なら 左辺に右辺を代入する、という意味になります。
　

メモ
 putsメゾットは、配列を出力するとき配列内の要素を一つずつ取り出し出力する。
 変数の式展開#{}は、二重引用符" "では効きますが、一重引用符' 'の中では効きません。 

気になった問題
①
N= gets.to_i
puts "*" * N　これだとOKで
N= gets.to_i
puts N * "*"これだとNG　　String can't be coerced into Integer (TypeError)　となる
→最初のは、文字列"*"を＊ N個　となるが、　最後のは、数字Nを＊文字列個となるため、ダメ。
②
N = gets.chomp
N.chars.each_with_index do |i, index|
  print ',' if index % 3 == 0 && index != 0
  print i
end
→数値を3桁事に,で区切る。　ただしこれは、入力される数値が3の倍数である時、そうで無いときは↓
test_string = gets.chomp.reverse
string_box = []
test_string.chars.each_with_index do |i,index|
    string_box << "," if index % 3 == 0 && index != 0
    string_box << i
end
puts string_box.join.reverse　こんな感じ。
③
9 個の数値が半角スペース区切りで入力されます　3 * 3 の出力せよ。　数値の間に余白を入れる。
numbers = gets.split.map(&:to_i)
(0..8).each do |i|　　#配列のindexにて繰り返し処理
 if i % 3 == 2
  puts numbers[i]
 else 
  print numbers[i]
  print " "
 end
end
④
九九表を作る
(1..9).each do |i| #数値をかける側
    numbers = (1..9).map{|j| j * i } #数値をかけられる側
    puts numbers.join(" ")
end
数値をかける側とかけれれる側でコードを分けると簡単であった。
⑤
自然数 N と N 個の要素の数列 M が与えられます。1 ≦ i ≦ N の各 i について、i 行目には以下の数列を出力してください。
* 1 以上 M_i 以下のすべての自然数を昇順、半角スペース区切りで出力してください。
N = gets.to_i
M = gets.split.map(&:to_i)
(1..N).each do |i|
    puts (1..M[i - 1]).to_a.join(" ")
end
#ここで大事なのが配列MのIndex数値と行数の違い。
⑥
実数 N、自然数 M が入力されます。N を丸めて小数第 M 位まで出力してください。
また、N の小数部が小数第 M 位に満たない場合は 0 で埋めて出力してください。

最初はこう書いた
numbers = gets.split
N = numbers[0].to_f
M = numbers[1].to_i
puts N.round(M)　
これだと、「満たない場合は、０で埋めて」ができない。
なので、sprintfフォーマットを利用する
numbers = gets.split
N = numbers[0].to_f
M = numbers[1].to_i
puts sprintf("%.#{M}f", N)

⑦自然数 Q が与えられます。Q 回以下の問題に答えてください。
実数 N、自然数 M が入力されます。N を丸めて小数第 M 位まで出力してください。また、N の小数部が小数第 M 位に満たない場合は 0 で埋めて出力してください。
Q = gets.to_i
Q.times do
    numbers = gets.split
    N = numbers[0].to_f
    M = numbers[1].to_i
    n = N.round(M)
    puts sprintf( "%.#{M}f", n )
end　こう書いた。　そうすると正常に動くが、Warning: already initialized constant Nというエラーが出る。繰り返し処理の内部へ変数を定義しているから。
なのでこう書いた。↓
Q = gets.to_i
Q.times do
    numbers = gets.split
    n = numbers[0].to_f.round(numbers[1].to_i)　#roundメゾットで四捨五入
    puts sprintf( "%.#{numbers[1].to_i}f", n )　#sprintfフォーマットにて小数点numbers[1]とした。
end
⑧自然数 H, W, A, B が与えられます。縦に H 行、横に W 行で計 H * W 個の (A, B) という形式の文字列を出力してください。
ただし、横は | (半角スペース バーティカルライン 半角スペース) 区切りで、縦は = で区切って出力してください。
また、縦の文字列間で = を出力する際は、その上の行と文字数が等しくなるように出力します。
numbers = gets.split.map(&:to_i)
H = numbers[0]
W = numbers[1]
A = numbers[2]
B = numbers[3]

test_array = []

W.times do
 test_array << "(#{A}, #{B})"
end
H.times do |h|
 puts test_array.join(" | ")
  if h != H - 1
   puts "=" * test_array.join(" | ").length
  end
end　が正しい
自分がミスした点が二つあり一つ目が、test_arrayの配列に代入する方法。
最初はこう書いた。　
test_array = [] 
test_array　<< "(#{A}, #{B})" * W
これだと、"(#{A}, #{B})"をW回数だけ繰り返すが繰り返した分test_arrayに代入されるわけではない。
二つめが、＝を出力する方法
H.times do |h| 
　puts test_array.join(" | ") 
　if h != H 
　puts "=" *　test_array.join(" | ").length
と書いた。ここでおかしいのが　h != H である。h は 0 から H-1 までの値を取るから、h が H になることはない
⑨
1 行目で、整数 N と、続けて N 個の実数 a_1, ... , a_N が半角スペース区切りで与えられます。
a_1, ... , a_N を改行区切りでそのまま出力してください
自分は最初こう書いた↓
numbers = gets.split
N = numbers[0].to_i
float_array = numbers[1..N].to_f
puts float_array　これだとエラーとなる。 Arrayクラスにto_fメゾットなんてないよと。
なので、　float_array = numbers[1..N].to_f　から　float_array = numbers[1..N].map{ |n| n.to_f }　へ変更した。
⑩
1 行目に整数 N が与えられます。
2 行目以降に、N 組の文字列 s_i と整数 a_i が N 行で与えられます。(1 ≦ i ≦ N)
N 組の s_i と a_i を改行区切りで出力してください。
N = gets.to_i
N.times do
 mix_array = gets.split
 test_array = mix_array.map.with_index{ |m,idx| idx == 1 ? m.to_i : m }
 puts test_array.join(" ")
end
ここで、最初ミスしたのが、{}の処理で後置ifを使用した。その場合は、idxが1のものだけをtest_arrayに代入された。
なので、if 三項演算子を採用した。
⑪
要素数 N の数列 A と要素数 Q の数列 B が与えられます。 1 ≦ i ≦ Q の各 i について、i 行目に A の B_i 番目の値を出力してください。
N = gets.to_i
A = gets.split.map(&:to_i)
Q = gets.to_i
B = gets.split.map(&:to_i)

B.each do |b|
    puts A[b - 1]
end　→めっちゃ考えたけど簡単だった。説明不要。

⑫
とても小さな数値Nが与えられます。そのまま出力してください。
条件
すべてのテストケースにおいて、以下の条件をみたします。
・ N は実数
・ 0 ≦ N < 100
・ N は高々小数第 100 位まで与えられる
私は、puts gets.to_fとしたしかしNG
→解説　
受け取った入力をそのまま出力します。
一般に、各言語に用意されている実数型には精度に限界があり、実数を誤差なく保持することは難しいです。
そこで、実数を文字列とみなし、文字列型を使います。　なのでgets.chomp でいい

⑬
縦 H マス、横 W マスの H × W マスからなる迷路 S があります。上から i 行目、左から j 列目のマス は S_ij とあらわされ、 S_ij が「#」のとき壁であり、「.」のとき道です。
整数 r、c が与えられるので、S_rc が壁かどうか判定してください。

入力例1
3 4 1 2
..#.
#.##
....

H, W, r, c = gets.split.map(&:to_i)
maze = Array.new(H) { gets.chomp }

if maze[r - 1][c - 1] == "#"
    puts "Yes"
else
    puts "No"
end
コード解説
二次元配列のような構造を利用する。ただし、厳密には「文字列の配列」である。
[
  "#####",
  "#...#",
  "#.#.#",
  "#####"
]
こんな感じのイメージ。
Array.new(H) { gets.chomp }　これは、H個の要素(gets.chomp)を受け取った、それぞれの行が異なる一つの配列である。
通常、ary = Array.new(3){ "foo" }のように、3つの要素が同じ文字列"foo"を持つ配列を作るから、一行として表示される。　  #=> ["foo", "foo", "foo"]
しかし、gets.chompは改行されるから、今回は改行された配列となる。

○
0 以上 9 以下の整数が N 個与えられます。各数値の出現回数を求め、「0」の出現回数、「1」の出現回数、...「9」の出現回数、をこの順に半角スペース区切りで1行に出力してください。
N = gets.to_i
A = gets.split.map(&:to_i)

count = Array.new(10, 0)
A.each do |num|
  count[num] += 1
end

puts count.join(" ")


○
文字列が N 個与えられます。各文字列の出現回数を文字列の辞書順に出力してください。
入力例1
5
bcd
abc
bcd
bcd
bcd

出力例1
abc 1
bcd 4

N = gets.to_i
count = Hash.new(0)

N.times do
  s = gets.chomp
  count[s] += 1
end

count.keys.sort.each do |word|
  puts "#{word} #{count[word]}"
end
と書く。
コード説明
・Hash.new(0)とHash.new()の違い。
存在しないキーが指定されるとデフォルト値でnilを返すか0を返すかの違いね。
・count[s] += 1 
これはハッシュcountに対して[]にキーを指定している。
count[s] = count[s] + 1  であり、
左辺は、countsハッシュに新たなキーを指定
右辺は、counts[s]にて値を取得し、＋1することで値を完成している。
デフォルトで値は0なので、1ずつカウントされるイメージ
・count.keys.sort.each do |word|
keysメゾットにてハッシュのキーを配列で取得　配列なら繰り返し処理可能。
sortメゾットにて配列内を入れ替え。

○
N 個の文字列 S_1, ... , S_N と、Q 個の文字列 T_1, ... , T_Q が与えられます。各 T_i について、以下の処理を行ってください。
・ S_j == T_i を満たす最小の j を出力する。ただし、そのような j が存在しない場合は -1 を出力する。
入力例1
3 2
a
b
c
b
d

出力例1
2
-1

N,Q = gets.split.map(&:to_i)
test_hash = {}
N.times do |n|
    i  = gets.chomp
    test_hash[i] ||= n + 1　　←ここで自己代入している　||=  左辺がfalseか空なら左辺を右辺に入れる。この場合test_hassh[i]の値を　n+1する感じ。
　　　　　　　　　　　　　　　　　これだと、問題のS_j == T_i を満たす最小の j を出力するを満足出来る。　同じキーが来たら　n+1しないからね。
end
Q.times do
    q = gets.chomp
    if test_hash.key?(q)
        puts test_hash[q]
    else
        puts -1
    end
end　と書いた。
